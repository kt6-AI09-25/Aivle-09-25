<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>발표녹화 페이지</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        /* 비디오 컨테이너 (카운트다운, 타이머 오버레이를 위해) */
        .video-container {
          position: relative;
          display: block;
          margin: 20px auto;
          width: 900px;
          height: 500px;
          border: 2px solid black; /* 비디오 테두리를 컨테이너로 이동 */
        }
        .video-container video {
          width: 100%;
          height: 100%;
          object-fit: cover;
          transform: scaleX(-1); /* 좌우 반전(거울모드) */
        }

        .controls {
          text-align: center;
          margin-top: 10px;
        }

        /* 원래 중앙에 있던 #timer는 숨김, 대신 #timerOverlay 사용 */
        #timer {
          display: none;
        }

        /* 로딩 화면 스타일 */
        #loadingModal {
          display: none;
          position: fixed;
          z-index: 2;
          left: 0; top: 0;
          width: 100%; height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          text-align: center;
          padding-top: 20%;
          font-size: 24px;
        }

        /* 마이크 게이지 */
        #audioMeter {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 90%;
          height: 50px;
          margin: 20px auto;
          position: relative;
        }
        .bar {
          width: 3px;
          margin: 0 1px;
          height: 20px;
          background-color: #ff3b3b;
          display: inline-block;
          transition: height 0.1s;
        }

        /* 카운트다운/화면 어둡게 */
        #darkOverlay {
          display: none;
          position: absolute;
          top: 0; left: 0; right: 0; bottom: 0;
          background-color: rgba(0,0,0,0.4);
          z-index: 9;
        }
        #countdownOverlay {
          display: none;
          position: absolute;
          top: 50%; left: 50%;
          transform: translate(-50%, -50%);
          font-size: 100px;
          font-weight: bold;
          color: #ccc; /* 아주 옅은 회색 */
          font-family: 'Arial', sans-serif;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
          z-index: 10;
        }

        /* 녹화 타이머 (오른쪽 상단) */
        #timerOverlay {
          display: none;
          position: absolute;
          top: 10px; right: 10px;
          font-size: 24px;
          color: #fff;
          font-weight: bold;
          font-family: 'Arial', sans-serif;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
          z-index: 10;
        }
    </style>
</head>
<body>
<div th:replace="navbar.html"></div>

<!-- 로딩 화면 -->
<div id="loadingModal">로딩 중입니다...</div>

<!-- 비디오 + 오버레이 -->
<div class="video-container">
    <video id="myVideo" autoplay playsinline></video>
    <div id="darkOverlay"></div>
    <div id="countdownOverlay">5</div>
    <div id="timerOverlay">00:00</div>
</div>

<!-- (원래 중앙에 표시되던 타이머) -->
<div id="timer">00:00</div>

<!-- 마이크 게이지 -->
<div id="audioMeter"></div>

<!-- 버튼 컨트롤 -->
<div class="controls">
    <button id="startBtn">발표 시작</button>
    <button id="stopBtn" disabled>발표 중지</button>
    <button id="viewResultsBtn">평가받기</button>
</div>

<script>
    let stream;               // 카메라/마이크 스트림
    let mediaRecorder;        // MediaRecorder
    let recordedChunks = [];
    let timerInterval;
    let seconds = 0;
    let audioContext;
    let analyser;
    let microphone;
    const bars = [];

    // === 새 전역 상태 ===
    let isRecording = false;  // true면 녹화 중
    let isPaused = false;     // true면 일시중지 중

    // 요소 참조
    const darkOverlay = document.getElementById('darkOverlay');
    const countdownOverlay = document.getElementById('countdownOverlay');
    const timerOverlay = document.getElementById('timerOverlay');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const viewResultsBtn = document.getElementById('viewResultsBtn');

    // 1) 페이지 로드 시 카메라/마이크 스트림 연결
    window.addEventListener('load', async () => {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 900, height: 500 },
          audio: true
        });
        const video = document.getElementById('myVideo');
        video.srcObject = stream;

        // 오디오 분석 초기화
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);

        createAudioBars();
        monitorAudioLevel();

        console.log("카메라/마이크 준비 완료 (녹화 전).");
      } catch (error) {
        console.error("카메라/마이크 초기화 오류:", error);
        alert("카메라/마이크를 사용할 수 없습니다: " + error.message);
      }
    });

    // 2) 발표 시작 or 다시시작
    async function startPresentation() {
      // - 아직 녹화를 시작 안 했거나(Idle),
      // - 이전 녹화를 끝낸 뒤 "다시시작"하는 경우
      // 카운트다운 → 새 MediaRecorder
      try {
        if (!stream) {
          alert("카메라 스트림이 없습니다. 다시 시도하세요.");
          return;
        }

        // 버튼 상태
        startBtn.disabled = true;
        stopBtn.disabled = true;

        // 어둡게 + 카운트다운 표시
        darkOverlay.style.display = 'block';
        countdownOverlay.style.display = 'block';

        let countdownNumber = 5;
        countdownOverlay.textContent = countdownNumber;

        let countdownInterval = setInterval(() => {
          countdownNumber--;
          countdownOverlay.textContent = countdownNumber;

          if (countdownNumber <= 0) {
            clearInterval(countdownInterval);
            countdownOverlay.style.display = 'none';
            darkOverlay.style.display = 'none';

            // --- MediaRecorder 준비 ---
            mediaRecorder = new MediaRecorder(stream);
            recordedChunks = [];

            // dataavailable → chunk 저장
            mediaRecorder.ondataavailable = function(event) {
              if (event.data.size > 0) {
                recordedChunks.push(event.data);
              }
            };

            // stop → 업로드
            mediaRecorder.onstop = async function() {
              const blob = new Blob(recordedChunks, { type: 'video/webm' });
              const formData = new FormData();
              formData.append('file', blob, 'presentation.webm');

              try {
                const response = await fetch('/files/upload', {
                  method: 'POST',
                  body: formData
                });
                if (response.ok) {
                  console.log("녹화본 업로드 성공");
                } else {
                  console.error("서버 응답 오류:", response.statusText);
                  alert("녹화본 업로드에 실패했습니다.");
                }
              } catch (error) {
                console.error("업로드 중 오류:", error);
                alert("녹화본 업로드 중 문제가 발생했습니다.");
              }
            };

            // 녹화 시작
            mediaRecorder.start();
            isRecording = true;
            isPaused = false;

            // 타이머 초기화 후 시작
            seconds = 0;
            document.getElementById('timer').textContent = "00:00";
            timerOverlay.textContent = "00:00";
            timerOverlay.style.display = 'block'; // 오른쪽 상단 타이머 표시
            timerInterval = setInterval(updateTimer, 1000);

            console.log("발표 녹화 시작");

            // 버튼 상태 갱신
            stopBtn.disabled = false;
            stopBtn.textContent = "발표중지";
            startBtn.textContent = "다시시작";
            startBtn.disabled = false; // 이제 "다시시작" 버튼 가능
          }
        }, 1000);

      } catch (error) {
        console.error("발표 시작 오류:", error);
        alert("발표를 시작할 수 없습니다: " + error.message);
      }
    }

    // 3) 발표 중지 or 재개 (pause/resume)
    function togglePause() {
      if (!mediaRecorder) return;

      // 현재 녹화 중 → 일시중지
      if (isRecording && !isPaused) {
        mediaRecorder.pause();
        console.log("녹화 일시중지");
        isRecording = false;
        isPaused = true;

        clearInterval(timerInterval); // 타이머 멈춤
        stopBtn.textContent = "발표재개";
        startBtn.textContent = "다시시작"; // 계속 유지(새로 다시 시작 가능)
      }
      // 일시중지 상태 → 재개
      else if (!isRecording && isPaused) {
        mediaRecorder.resume();
        console.log("녹화 재개");
        isRecording = true;
        isPaused = false;

        // 타이머 재시작
        timerInterval = setInterval(updateTimer, 1000);
        stopBtn.textContent = "발표 중지";
        // startBtn은 "발표 다시시작" 그대로
      }
    }

    // "발표 다시시작" → 기존 녹화 stop() & 새로 start()
    function restartPresentation() {
      if (mediaRecorder && (isRecording || isPaused)) {
        mediaRecorder.stop(); // 업로드까지 onstop()에서 처리
        console.log("기존 녹화 stop() 후 새로 시작");
        clearInterval(timerInterval);
        timerOverlay.style.display = 'none';
      }
      // 새 녹화
      startPresentation();
    }

    // 4) 분석 결과 보기
    viewResultsBtn.addEventListener('click', function() {
      document.getElementById('loadingModal').style.display = 'block'; // 로딩 표시
      setTimeout(function() {
        window.location.href = "myresult";
      }, 1000);
    });

    // 5) 버튼 클릭 이벤트
    startBtn.addEventListener('click', function() {
      // 현재 녹화 중이 아니거나, 이미 "발표 다시시작" 상태
      // → restartPresentation()로 처리
      if (!isRecording && !isPaused && mediaRecorder) {
        // 이미 한 번 녹화했던 상태라면 재시작
        // (만약 완전히 Idle 상태라면 그냥 startPresentation()만 해도 OK)
        restartPresentation();
      } else if (isPaused || isRecording) {
        // 녹화 중이거나 일시중지라면 "발표 다시시작"을 누른 것으로 간주
        restartPresentation();
      } else {
        // 완전히 처음(Idle) 상태
        startPresentation();
      }
    });

    stopBtn.addEventListener('click', togglePause);

    // ====== 타이머 ======
    function updateTimer() {
      seconds++;
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;

      // (숨겨진) #timer
      document.getElementById('timer').textContent =
        `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;

      // 오른쪽 상단 #timerOverlay
      timerOverlay.textContent =
        `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    // ====== 오디오 게이지 ======
    function createAudioBars() {
      const audioMeter = document.getElementById('audioMeter');
      for (let i = 0; i < 40; i++) {
        const bar = document.createElement('div');
        bar.classList.add('bar');
        bars.push(bar);
        audioMeter.appendChild(bar);
      }
    }

    function monitorAudioLevel() {
      const dataArray = new Uint8Array(analyser.fftSize);

      function updateAudioLevel() {
        analyser.getByteFrequencyData(dataArray);
        for (let i = 0; i < bars.length; i++) {
          const barHeight = dataArray[i] / 256 * 50;
          bars[i].style.height = `${barHeight}px`;
        }
        requestAnimationFrame(updateAudioLevel);
      }
      updateAudioLevel();
    }
</script>
</body>
</html>
