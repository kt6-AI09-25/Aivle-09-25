<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>면접 녹화 및 결과 페이지</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    /* 비디오 컨테이너 (카운트다운, 타이머 오버레이를 위해) */
    .video-container {
      position: relative;
      display: block;
      margin: 20px auto;
      width: 900px;
      height: 500px;
      border: 2px solid black;
    }
    .video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 거울모드 */
    }
    .controls {
      text-align: center;
      margin-top: 10px;
    }
    /* 숨겨진 타이머 (디버그용) */
    #timer {
      display: none;
    }
    /* 로딩 화면 */
    #loadingModal {
      display: none;
      position: fixed;
      z-index: 2;
      left: 0; top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      text-align: center;
      padding-top: 20%;
      font-size: 24px;
    }
    /* 마이크 게이지 */
    #audioMeter {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 90%;
      height: 50px;
      margin: 20px auto;
      position: relative;
    }
    .bar {
      width: 3px;
      margin: 0 1px;
      height: 20px;
      background-color: #ff3b3b;
      display: inline-block;
      transition: height 0.1s;
    }
    /* 카운트다운 및 어둡게 처리 */
    #darkOverlay {
      display: none;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.4);
      z-index: 9;
    }
    #countdownOverlay {
      display: none;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 100px;
      font-weight: bold;
      color: #ccc;
      font-family: 'Arial', sans-serif;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      z-index: 10;
    }
    /* 오른쪽 상단 타이머 오버레이 */
    #timerOverlay {
      display: none;
      position: absolute;
      top: 10px; right: 10px;
      font-size: 24px;
      color: #fff;
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      z-index: 10;
    }
  </style>
</head>
<body>
<!-- 네비게이션 (Thymeleaf include) -->
<div th:replace="navbar.html"></div>

<!-- 로딩 화면 -->
<div id="loadingModal">로딩 중입니다...</div>

<!-- 비디오 및 오버레이 영역 -->
<div class="video-container">
  <video id="myVideo" autoplay playsinline></video>
  <div id="darkOverlay"></div>
  <div id="countdownOverlay">5</div>
  <div id="timerOverlay">00:00</div>
</div>

<!-- (디버그용 숨겨진 타이머) -->
<div id="timer">00:00</div>

<!-- 마이크 게이지 -->
<div id="audioMeter"></div>

<!-- 버튼 컨트롤 -->
<div class="controls">
  <button id="startBtn">면접 시작</button>
  <button id="stopBtn" disabled>면접 종료</button>
  <button id="viewResultsBtn">평가받기</button>
</div>

<script>
  let stream;               // 카메라/마이크 스트림
  let mediaRecorder;        // MediaRecorder 객체
  let recordedChunks = [];  // 녹화 데이터 조각 저장
  let timerInterval;
  let seconds = 0;
  let audioContext;
  let analyser;
  let microphone;
  const bars = [];

  // 녹화 상태 플래그
  let isRecording = false;  // 녹화 중이면 true

  // 업로드된 파일 경로 저장 (필요 시 사용)
  let uploadedFilePath = "";

  // 요소 참조
  const darkOverlay = document.getElementById('darkOverlay');
  const countdownOverlay = document.getElementById('countdownOverlay');
  const timerOverlay = document.getElementById('timerOverlay');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const viewResultsBtn = document.getElementById('viewResultsBtn');
  const loadingModal = document.getElementById('loadingModal');

  // 페이지 로드 시 카메라/마이크 스트림 연결 및 오디오 분석 설정
  window.addEventListener('load', async () => {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 900, height: 500 },
        audio: true
      });
      const video = document.getElementById('myVideo');
      video.srcObject = stream;

      // 오디오 분석 초기화
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      microphone = audioContext.createMediaStreamSource(stream);
      microphone.connect(analyser);

      createAudioBars();
      monitorAudioLevel();

      console.log("카메라/마이크 준비 완료 (녹화 전).");
    } catch (error) {
      console.error("카메라/마이크 초기화 오류:", error);
      alert("카메라/마이크를 사용할 수 없습니다: " + error.message);
    }
  });

  // 타이머 업데이트 함수
  function updateTimer() {
    seconds++;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    // 디버그용 숨겨진 타이머 업데이트
    document.getElementById('timer').textContent =
      `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    // 오른쪽 상단 타이머 오버레이 업데이트
    timerOverlay.textContent =
      `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  // 오디오 레벨 바 생성
  function createAudioBars() {
    const audioMeter = document.getElementById('audioMeter');
    for (let i = 0; i < 40; i++) {
      const bar = document.createElement('div');
      bar.classList.add('bar');
      bars.push(bar);
      audioMeter.appendChild(bar);
    }
  }

  // 오디오 레벨 모니터링
  function monitorAudioLevel() {
    const dataArray = new Uint8Array(analyser.fftSize);
    function updateAudioLevel() {
      analyser.getByteFrequencyData(dataArray);
      for (let i = 0; i < bars.length; i++) {
        const barHeight = dataArray[i] / 256 * 50;
        bars[i].style.height = `${barHeight}px`;
      }
      requestAnimationFrame(updateAudioLevel);
    }
    updateAudioLevel();
  }

  // 면접(녹화) 시작 함수: 카운트다운 후 녹화 시작
  async function startPresentation() {
    try {
      if (!stream) {
        alert("카메라 스트림이 없습니다. 다시 시도하세요.");
        return;
      }
      // 버튼 상태 변경
      startBtn.disabled = true;
      stopBtn.disabled = true;
      // 어둡게 처리 및 카운트다운 표시
      darkOverlay.style.display = 'block';
      countdownOverlay.style.display = 'block';
      let countdownNumber = 5;
      countdownOverlay.textContent = countdownNumber;
      let countdownInterval = setInterval(() => {
        countdownNumber--;
        countdownOverlay.textContent = countdownNumber;
        if (countdownNumber <= 0) {
          clearInterval(countdownInterval);
          countdownOverlay.style.display = 'none';
          darkOverlay.style.display = 'none';
          // MediaRecorder 초기화
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];
          mediaRecorder.ondataavailable = function(event) {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };
          mediaRecorder.onstop = async function() {
            console.log("녹화가 중지되었습니다.");
            // 업로드는 "평가받기" 버튼을 통해 별도로 진행
          };
          // 녹화 시작
          mediaRecorder.start();
          isRecording = true;
          seconds = 0;
          document.getElementById('timer').textContent = "00:00";
          timerOverlay.textContent = "00:00";
          timerOverlay.style.display = 'block';
          timerInterval = setInterval(updateTimer, 1000);
          console.log("면접 녹화 시작");
          // 버튼 상태 갱신
          stopBtn.disabled = false;
          stopBtn.textContent = "면접 종료";
        }
      }, 1000);
    } catch (error) {
      console.error("녹화 시작 오류:", error);
      alert("면접 녹화를 시작할 수 없습니다: " + error.message);
    }
  }

  // 면접 녹화 종료 함수
  function stopPresentation() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      console.log("면접 녹화 종료");
      clearInterval(timerInterval);
      timerOverlay.style.display = 'none';
      isRecording = false;
      // 버튼 상태 갱신
      stopBtn.disabled = true;
      startBtn.disabled = false;
    }
  }

  // 녹화된 영상을 로컬에 다운로드(저장)하는 함수
  function saveVideoLocally() {
    if (recordedChunks.length === 0) return;
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'recorded_video.webm';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log("영상이 로컬에 저장되었습니다.");
  }

  // 녹화본 업로드 및 결과 페이지 이동 함수
  async function uploadAndGoToResults() {
    if (recordedChunks.length === 0) {
      alert("녹화된 파일이 없습니다.");
      return;
    }
    viewResultsBtn.disabled = true;
    loadingModal.style.display = 'block';
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const formData = new FormData();
    formData.append('file', blob, 'presentation.webm');
    try {
      // 업로드 엔드포인트를 실제 환경에 맞게 수정하세요.
      const response = await fetch('/files/upload/results', {
        method: 'POST',
        body: formData
      });
      if (response.ok) {
        const result = await response.json();
        uploadedFilePath = result.filePath;
        console.log("녹화본 업로드 성공:", uploadedFilePath);
        // 녹화된 영상도 로컬에 저장
        saveVideoLocally();
        // 결과 페이지로 이동 (쿼리 파라미터 전달)
        window.location.href = `/files/upload/results?filePath=${encodeURIComponent(uploadedFilePath)}`;
      } else {
        console.error("서버 응답 오류:", response.statusText);
        alert("녹화본 업로드에 실패했습니다.");
      }
    } catch (error) {
      console.error("업로드 중 오류:", error);
      alert("녹화본 업로드 중 문제가 발생했습니다.");
    } finally {
      loadingModal.style.display = 'none';
      viewResultsBtn.disabled = false;
    }
  }

  // 버튼 이벤트 리스너 등록
  startBtn.addEventListener('click', startPresentation);
  stopBtn.addEventListener('click', stopPresentation);
  viewResultsBtn.addEventListener('click', uploadAndGoToResults);
</script>
</body>
</html>
