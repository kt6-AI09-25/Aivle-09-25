<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>면접 녹화 및 결과 페이지</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    /* 비디오 컨테이너 (카운트다운, 타이머 오버레이, 질문 오버레이를 위해) */
    .video-container {
      position: relative;
      display: block;
      margin: 20px auto;
      width: 900px;
      height: 500px;
      border: 2px solid black;
    }
    .video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 거울모드 */
    }
    /* 질문 오버레이 (캠 화면 위에 나타남) */
    #questionContainer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 10px;
      border-radius: 5px;
      display: none;
      text-align: center;
    }
    #questionContainer button {
      margin-left: 10px;
    }
    .controls {
      text-align: center;
      margin-top: 10px;
    }
    /* 숨겨진 타이머 (디버그용) */
    #timer {
      display: none;
    }
    /* 로딩 화면 */
    #loadingModal {
      display: none;
      position: fixed;
      z-index: 2;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      text-align: center;
      padding-top: 20%;
      font-size: 24px;
    }
    /* 마이크 게이지 */
    #audioMeter {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 90%;
      height: 50px;
      margin: 20px auto;
      position: relative;
    }
    .bar {
      width: 3px;
      margin: 0 1px;
      height: 20px;
      background-color: #ff3b3b;
      display: inline-block;
      transition: height 0.1s;
    }
    /* 카운트다운 및 어둡게 처리 */
    #darkOverlay {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 9;
    }
    #countdownOverlay {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 100px;
      font-weight: bold;
      color: #ccc;
      font-family: 'Arial', sans-serif;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }
    /* 오른쪽 상단 타이머 오버레이 */
    #timerOverlay {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      color: #fff;
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }
  </style>
</head>
<body>
<!-- 네비게이션 (Thymeleaf include) -->
<div th:replace="navbar.html"></div>

<!-- 로딩 화면 -->
<div id="loadingModal">로딩 중입니다...</div>

<!-- 비디오 및 오버레이 영역 -->
<div class="video-container">
  <video id="myVideo" autoplay playsinline></video>
  <div id="darkOverlay"></div>
  <div id="countdownOverlay">5</div>
  <div id="timerOverlay">00:00</div>
  <!-- 질문 오버레이 -->
  <div id="questionContainer">
    <div id="questionText"></div>
    <button id="questionNextBtn" style="display: none;">다음</button>
    <button id="evaluateBtn" style="display: none;">평가받기</button>
  </div>
</div>

<!-- (디버그용 숨겨진 타이머) -->
<div id="timer">00:00</div>

<!-- 마이크 게이지 -->
<div id="audioMeter"></div>

<!-- 버튼 컨트롤 (평가받기 버튼는 질문 오버레이로 이동시킴, 기존 버튼은 숨김) -->
<div class="controls">
  <button id="startBtn">면접 시작</button>
  <button id="stopBtn" disabled>면접 종료</button>
  <!-- 기존 평가받기 버튼은 숨김 -->
  <button id="viewResultsBtn" style="display:none;">평가받기</button>
</div>

<script>
  /***** 기존 녹화 및 업로드 관련 코드 *****/
  let stream;               // 카메라/마이크 스트림
  let mediaRecorder;        // MediaRecorder 객체
  let recordedChunks = [];  // 녹화 데이터 조각 저장
  let timerInterval;
  let seconds = 0;
  let audioContext;
  let analyser;
  let microphone;
  const bars = [];

  // 녹화 상태 플래그
  let isRecording = false;  // 녹화 중이면 true

  // 업로드된 파일 경로 저장 (필요 시 사용)
  let uploadedFilePath = "";

  // 요소 참조
  const darkOverlay = document.getElementById('darkOverlay');
  const countdownOverlay = document.getElementById('countdownOverlay');
  const timerOverlay = document.getElementById('timerOverlay');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const viewResultsBtn = document.getElementById('viewResultsBtn');
  const loadingModal = document.getElementById('loadingModal');

  // 페이지 로드 시 카메라/마이크 스트림 연결 및 오디오 분석 설정
  window.addEventListener('load', async () => {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 900, height: 500 },
        audio: true
      });
      const video = document.getElementById('myVideo');
      video.srcObject = stream;

      // 오디오 분석 초기화
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      microphone = audioContext.createMediaStreamSource(stream);
      microphone.connect(analyser);

      createAudioBars();
      monitorAudioLevel();

      console.log("카메라/마이크 준비 완료 (녹화 전).");
    } catch (error) {
      console.error("카메라/마이크 초기화 오류:", error);
      alert("카메라/마이크를 사용할 수 없습니다: " + error.message);
    }
  });

  // 타이머 업데이트 함수
  function updateTimer() {
    seconds++;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    // 디버그용 숨겨진 타이머 업데이트
    document.getElementById('timer').textContent =
      `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    // 오른쪽 상단 타이머 오버레이 업데이트
    timerOverlay.textContent =
      `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  // 오디오 레벨 바 생성
  function createAudioBars() {
    const audioMeter = document.getElementById('audioMeter');
    for (let i = 0; i < 40; i++) {
      const bar = document.createElement('div');
      bar.classList.add('bar');
      bars.push(bar);
      audioMeter.appendChild(bar);
    }
  }

  // 오디오 레벨 모니터링
  function monitorAudioLevel() {
    const dataArray = new Uint8Array(analyser.fftSize);
    function updateAudioLevel() {
      analyser.getByteFrequencyData(dataArray);
      for (let i = 0; i < bars.length; i++) {
        const barHeight = dataArray[i] / 256 * 50;
        bars[i].style.height = `${barHeight}px`;
      }
      requestAnimationFrame(updateAudioLevel);
    }
    updateAudioLevel();
  }

  // 면접(녹화) 시작 함수: 카운트다운 후 녹화 시작
  async function startPresentation() {
    try {
      if (!stream) {
        alert("카메라 스트림이 없습니다. 다시 시도하세요.");
        return;
      }
      // 버튼 상태 변경
      startBtn.disabled = true;
      stopBtn.disabled = true;
      // 어둡게 처리 및 카운트다운 표시
      darkOverlay.style.display = 'block';
      countdownOverlay.style.display = 'block';
      let countdownNumber = 5;
      countdownOverlay.textContent = countdownNumber;
      let countdownInterval = setInterval(() => {
        countdownNumber--;
        countdownOverlay.textContent = countdownNumber;
        if (countdownNumber <= 0) {
          clearInterval(countdownInterval);
          countdownOverlay.style.display = 'none';
          darkOverlay.style.display = 'none';
          // MediaRecorder 초기화
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];
          mediaRecorder.ondataavailable = function(event) {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };
          mediaRecorder.onstop = async function() {
            console.log("녹화가 중지되었습니다.");
            // 업로드는 평가 버튼(질문 오버레이의 평가받기)에서 진행
          };
          // 녹화 시작
          mediaRecorder.start();
          isRecording = true;
          seconds = 0;
          document.getElementById('timer').textContent = "00:00";
          timerOverlay.textContent = "00:00";
          timerOverlay.style.display = 'block';
          timerInterval = setInterval(updateTimer, 1000);
          console.log("면접 녹화 시작");
          // 버튼 상태 갱신
          stopBtn.disabled = false;
          stopBtn.textContent = "면접 종료";
          // 시작 시, 질문 오버레이 표시 (첫 질문)
          currentQuestionIndex = 0;
          showQuestion(currentQuestionIndex);
        }
      }, 1000);
    } catch (error) {
      console.error("녹화 시작 오류:", error);
      alert("면접 녹화를 시작할 수 없습니다: " + error.message);
    }
  }

  // 면접 녹화 종료 함수
  function stopPresentation() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      console.log("면접 녹화 종료");
      clearInterval(timerInterval);
      timerOverlay.style.display = 'none';
      isRecording = false;
      // 버튼 상태 갱신
      stopBtn.disabled = true;
      startBtn.disabled = false;
    }
  }

  // 녹화된 영상을 로컬에 다운로드(저장)하는 함수
  function saveVideoLocally() {
    if (recordedChunks.length === 0) return;
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'recorded_video.webm';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log("영상이 로컬에 저장되었습니다.");
  }

  // 녹화본 업로드 및 결과 페이지 이동 함수 (myresult.html로 이동)
  async function uploadAndGoToResults() {
    if (recordedChunks.length === 0) {
      alert("녹화된 파일이 없습니다.");
      return;
    }
    viewResultsBtn.disabled = true;
    loadingModal.style.display = 'block';
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const formData = new FormData();
    formData.append('file', blob, 'presentation.webm');
    try {
      // 업로드 엔드포인트를 실제 환경에 맞게 수정하세요.
      const response = await fetch('/files/upload/results', {
        method: 'POST',
        body: formData
      });
      if (response.ok) {
        const result = await response.json();
        uploadedFilePath = result.filePath;
        console.log("녹화본 업로드 성공:", uploadedFilePath);
        // 녹화된 영상도 로컬에 저장
        saveVideoLocally();
        // 결과 페이지로 이동 (myresult.html로)
        window.location.href = `/myresult.html?filePath=${encodeURIComponent(uploadedFilePath)}`;
      } else {
        console.error("서버 응답 오류:", response.statusText);
        alert("녹화본 업로드에 실패했습니다.");
      }
    } catch (error) {
      console.error("업로드 중 오류:", error);
      alert("녹화본 업로드 중 문제가 발생했습니다.");
    } finally {
      loadingModal.style.display = 'none';
      viewResultsBtn.disabled = false;
    }
  }

  /***** 면접 질문 기능 *****/
  // 9개의 공통 면접 질문 배열
  const commonQuestions = [
    "자기소개를 해주세요.",
    "우리 회사에 지원한 동기는 무엇인가요?",
    "당신의 강점과 약점은 무엇인가요?",
    "이전에 어떤 프로젝트를 수행했는지 설명해 주세요.",
    "팀 내 갈등 상황을 어떻게 해결했는지 이야기해 주세요.",
    "앞으로의 경력 계획은 무엇인가요?",
    "문제를 해결했던 경험을 구체적으로 말씀해 주세요.",
    "리더십 경험에 대해 말씀해 주세요.",
    "당신이 가장 자랑스러웠던 성과는 무엇인가요?"
  ];

  // 9개 질문 중 3개를 중복 없이 무작위로 선택하는 함수
  function getRandomQuestions(num) {
    const shuffled = commonQuestions.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, num);
  }

  const selectedQuestions = getRandomQuestions(3);
  let currentQuestionIndex = 0;

  // 질문 오버레이 관련 요소 (이미 HTML에 추가되어 있음)
  const questionContainer = document.getElementById("questionContainer");
  const questionText = document.getElementById("questionText");
  const questionNextBtn = document.getElementById("questionNextBtn");
  const evaluateBtn = document.getElementById("evaluateBtn");

  // 질문을 표시하는 함수
  function showQuestion(index) {
    if (index < selectedQuestions.length) {
      questionText.textContent = selectedQuestions[index];
      questionContainer.style.display = "block";
      // 초기에는 버튼 모두 숨김
      questionNextBtn.style.display = "none";
      evaluateBtn.style.display = "none";
      // 10초 후에 버튼 표시: 마지막 질문이면 평가받기, 아니면 다음 버튼
      setTimeout(() => {
        if (index < selectedQuestions.length - 1) {
          questionNextBtn.style.display = "inline-block";
        } else {
          evaluateBtn.style.display = "inline-block";
        }
      }, 10000);
    }
  }

  // "다음" 버튼 클릭 시 다음 질문으로 전환
  questionNextBtn.addEventListener("click", () => {
    currentQuestionIndex++;
    if (currentQuestionIndex < selectedQuestions.length) {
      showQuestion(currentQuestionIndex);
    }
  });

  // "평가받기" 버튼 클릭 시 업로드 및 결과 페이지 이동
  evaluateBtn.addEventListener("click", () => {
    uploadAndGoToResults();
  });

  /***** 버튼 이벤트 리스너 등록 *****/
  startBtn.addEventListener('click', startPresentation);
  stopBtn.addEventListener('click', stopPresentation);
  // 기존 viewResultsBtn는 숨김(평가받기 버튼은 질문 오버레이에서 처리)
</script>
</body>
</html>
